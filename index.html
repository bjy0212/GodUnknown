<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>
	<p align="center">
		<b>Moving Ball</b>
	</p>
	<p>
		<canvas id="myCanvas" width="480" height="320"></canvas>
	</p>
	<p align="center"><button type="button" onclick="start();"/></p>

<script>
	const canvas = document.getElementById("myCanvas");
	const ctx = canvas.getContext("2d");

	let x = canvas.width / 2;
	let y = canvas.height - 30;

	let dx = +2;
	let dy = -2;

	let paddleHeight = 10;
	let paddleWidth = 75;
	let paddleX = (canvas.width - paddleWidth)/2;

	let keyDown = 0;

	//공의 반지름
	let ballRadius = 10;

	//벽돌들
	var brickRowCount = 3;
	var brickColumnCount = 5;
	var brickWidth = 75;
	var brickHeight = 20;
	var brickPadding = 10;
	var brickOffsetTop = 30;
	var brickOffsetLeft = 30;
	//벽돌들

	var score = 0;

	var bricks = [];
	for(var c=0; c<brickColumnCount; c++) {
	    bricks[c] = [];
	    for(var r=0; r<brickRowCount; r++) {
	        bricks[c][r] = { x: 0, y: 0, status: 1 };
	    }
	}

	function drawBricks() {
		for(var c=0; c<brickColumnCount; c++) {
	        for(var r=0; r<brickRowCount; r++) {
	            bricks[c][r].x = 0;
	            bricks[c][r].y = 0;

				if(bricks[c][r].status == 1) {
					var brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
					var brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
					bricks[c][r].x = brickX;
					bricks[c][r].y = brickY;
					ctx.beginPath();
					ctx.rect(brickX, brickY, brickWidth, brickHeight);
					ctx.fillStyle = "#0095DD";
					ctx.fill();
					ctx.closePath();
				}
	        }
	    }
	}

	function drawScore() {
		ctx.font = "16px Arial";
		ctx.fillStyle = "#0095DD";
		ctx.fillText("Score: "+score, 8, 20);
	}

	function drawBall() {
		ctx.beginPath();
		ctx.arc(x, y, ballRadius, 0, Math.PI*2);
		ctx.fillStyle = "#0095DD";
		ctx.fill();
		ctx.closePath();
	}

	function drawPaddle() {
		ctx.beginPath();
		ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
		ctx.fillStyle = "#0095DD";
		ctx.fill();
		ctx.closePath();
	}

	function draw() {
		//캔버스 지우기
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		if(keyDown === 39) {
			if(paddleX < canvas.width - paddleWidth) paddleX += 5;
		}
		if(keyDown === 37) {
			if(paddleX > 0) paddleX -= 5;
		}

		drawBall();
		drawPaddle();
		drawBricks();
		collisionDetection();
		drawScore();

		if(y + dy < ballRadius) dy *= -1;
		else if(y + dy > canvas.height - ballRadius) {
			if(x > paddleX && x < paddleX + paddleWidth) dy *= -1;
			else {
				alert("GAME OVER");
				document.location.reload();
			}
		}

		if(x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx *= -1;

		x += dx;
		y += dy;
	}

	function KeyDownHandler(e) {
		keyDown =  e.keyCode;
	}
	function KeyUpHandler(e) {
		if(e.keyCode === keyDown) {
			keyDown = 0;
		}
	}

	function collisionDetection() {
		for(var c=0; c<brickColumnCount; c++) {
	        for(var r=0; r<brickRowCount; r++) {
	            var b = bricks[c][r];
				if(b.status == 1) {
	            	if(x + ballRadius > b.x && x - ballRadius < b.x + brickWidth && y + ballRadius > b.y && y - ballRadius < b.y+brickHeight) {
	                	dy *= -1;
						b.status = 0;
						score++;
	            	}
					if(score == brickRowCount*brickColumnCount) {
                        alert("YOU WIN, CONGRATULATIONS!");
                        document.location.reload();
                        clearInterval(interval); // Needed for Chrome to end game
                    }
				}
	        }
	    }
	}

	document.addEventListener("keydown", KeyDownHandler, false);
	document.addEventListener("keyup", KeyUpHandler, false);

	var interval;
	function start() {
		interval = setInterval(draw, 10);
	}
</script>

</body>
</html>
